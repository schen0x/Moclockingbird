// RP2350A (Rpi pico 2 W)
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "uart_tx_8n2.pio.h"   // the .h auto generated by pioasm from .pio file
#include "uart_rx_8n1.pio.h"   // the .h auto generated by pioasm from .pio file
#include "rst.pio.h"   // the .h auto generated by pioasm from .pio file
#include "stdio.h"
#include "digests.h"
#include "pico/multicore.h"

const float UART_BAUD = 115200;
const PIO TX_pio = pio0; // pio0 or pio1
const uint TX_sm  = 0; // sm could be 0..3
const PIO RX_pio = pio1;
const uint RX_sm  = 1;
const uint TX_PIN = 0;          // GP0
const uint RX_PIN = 1;          // GP1
const PIO RST_pio = pio0;
const uint RST_sm  = 2;
const uint RST_PIN = 2;         // GP2

namespace TX {
    /* ==== [WRITE] uart_tx_8n2_program START ==== */
    /**
     * IN pio: the PIO instance, pio0 or pio1
     * IN sm: the State machine index (0..3)
     * IN offset: the instruction offset of the loaded program
     * IN pin: abs pin number?
     * IN baud: baud
     */
    static void uart_tx_8n2_program_init(PIO pio, uint sm, uint offset, uint pin, float baud) {
        pio_sm_config c = uart_tx_8n2_program_get_default_config(offset);
        // Tell PIO to initially drive output-high on the selected pin, then map PIO
        // onto that pin with the IO muxes.
        pio_sm_set_pins_with_mask64(pio, sm, 1ull << pin, 1ull << pin);
        pio_sm_set_pindirs_with_mask64(pio, sm, 1ull << pin, 1ull << pin);
        // "pin" init -- GPIO control: PIO module takes control
        pio_gpio_init(pio, pin);
        // gpio_pull_up(pin);
        // set the direction of "pin" of pio in sm to output during the init
        // because we are the debugger and we write first
        pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true); // start from out
        sm_config_set_set_pins(&c, pin, 1);
        sm_config_set_out_pins(&c, pin, 1);
        // TX FIFO length=4 (4x32bits) is used for transmit, RX FIFO length=4 is used for receive.
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_NONE);
        // sm_config_set_out_shift(&c, true, true, 8); // (c, shift_right=true, autopull=true, 8 bits a time) // FIFO (4x32bits) -> OSR (32 bits)
        sm_config_set_out_shift(&c, true, false, 8); // (c, shift_right=true, autopull=false, 8 bits a time) // FIFO (4x32bits) -> OSR (32 bits)
        sm_config_set_sideset_pins(&c, pin);
        float sys_hz = (float)clock_get_hz(clk_sys); // usually 125MHz
        /**
         * The clock divider slows the state machineâ€™s execution by masking the system
         * clock on some cycles, in a repeating pattern, so that the state machine does
         * not advance. Effectively this produces a slower clock for the state machine
         * to run from, which can be used to generate e.g. a particular UART baud rate.
         * 
         * An integer clock divisor of n will cause the state machine to run 1 cycle in every n.
         * may jitter if div too small (when baud too high) and is float
        */
        sm_config_set_clkdiv(&c, sys_hz / (8 * baud)); // because we send 1 bit each 8 cycle
        // State_machine, load our configuration, and jump to the start of the program
        pio_sm_init(pio, sm, offset, &c);
        // State_machine, start
        // pio_sm_set_enabled(pio, sm, true);
    }
  
  
    /*
     * Each STATE_MACHINE has 2 FIFOs, each FIFO is 4x32 bits
     * the .pio `OUT pin 1` shift 1 bit from the *OSR* to the pin
     * (FIFO is not OSR, so either config autopull `sm_config_set_out_shift`, or `PULL` in .pio manually)
     * (if manually: use `sm_config_set_out_shift` but set autopull false (to achieve idle high etc.))
    */
    static void uart_tx_8n2_send_bytes(PIO pio, uint sm, const uint8_t *bytes, size_t length) {
        for (size_t i = 0; i < length; ++i) {
            // alternative raw method: // pio->txf[sm] = (125000000 / (2 * 250)) - 3;
            // the function stalls the processor when the TX FIFO is full
            // TX FIFO is 4 x 32 bits (uint32_t), but it's fine since the sm is configured to autopull 8 bits a time
            pio_sm_put_blocking(pio, sm, bytes[i]);
        }
    }
    static void send_test_bytes(PIO pio, uint sm){
        const uint8_t payload[] = { 0x1, 0x2, 0x3, 0x4, 0x55 };
        for (int i = 0; i < 1; i++){
            uart_tx_8n2_send_bytes(pio, sm, payload, sizeof(payload));
            sleep_ms(30); // "cpu" sleep means no data for FIFO in 30ms, which blocks the sm thus achieve idle HIGH
        }
    }
    static inline void on (){
        pio_sm_set_enabled(TX_pio, TX_sm, true);
    }
    static inline void off (){
        pio_sm_set_enabled(TX_pio, TX_sm, false);
    }
    /* ==== uart_tx_8n2_program END ==== */
}

namespace RX {
    /* ==== [READ] uart_rx_8n1_program START ==== */
    static inline void uart_rx_8n1_program_init(PIO pio, uint sm, uint offset, uint pin, uint baud) {
        pio_sm_set_pins_with_mask64(pio, sm, 1ull << pin, 1ull << pin); // initial high
        pio_sm_set_pindirs_with_mask64(pio, sm, 0ull << pin, 1ull << pin);
        pio_gpio_init(pio, pin);
    
        pio_sm_config c = uart_rx_8n1_program_get_default_config(offset);
        sm_config_set_in_pins(&c, pin); // for WAIT, IN
        sm_config_set_jmp_pin(&c, pin); // for JMP
        // shift_right=true, autopush=false
        sm_config_set_in_shift(&c, true, false, 8);
        // sm_config_set_in_shift(&c, true, true, 8);
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_NONE);
        float div = (float)clock_get_hz(clk_sys) / (8*baud); // read 1 bit per 8 clock cycles
        sm_config_set_clkdiv(&c, div);
        
        pio_sm_init(pio, sm, offset, &c);
        // pio_sm_set_enabled(pio, sm, true);
    }
    
    static inline void on(){
        pio_sm_set_enabled(RX_pio, RX_sm, true);
    }
    
    static inline void off(){
        pio_sm_set_enabled(RX_pio, RX_sm, false);
    }
    
    /**
     * Return: -1               if FIFO empty
     * Return: uint8_t byte_val if data
     */
    // pin -> ISR -> RX FIFO
    // after sm1 start, it wait for a LOW and push 8 bits automatically to FIFO
    // No data: if a certain time pass, but FIFO is empty
    // give back control to TX if No data
    static inline int uart_rx_program_getc(PIO pio, uint sm) {
        while (pio_sm_is_rx_fifo_empty(pio, sm))
            return -1;
        // should exists something, otherwise it's error
        uint32_t res = pio_sm_get_blocking(pio, sm);
        return (uint8_t) (res >> 24);
        // ok (document version)
        // 8-bit read from the uppermost byte of the FIFO, as data is left-justified
        // io_rw_8 *rxfifo_shift = (io_rw_8*)&pio->rxf[sm] + 3;
        // while (pio_sm_is_rx_fifo_empty(pio, sm))
        //     tight_loop_contents();
        // return (char)*rxfifo_shift;
    }
    
    /*
     * Return: the count of message consumed, in bytes
    */
    static inline int read_all(PIO pio, uint sm) {
        int x = 0;
        int consumed_message_byte_count = 0;
        while ((x = uart_rx_program_getc(pio, sm)) > 0)
        {
            printf("B:%x", x);
        }
        return consumed_message_byte_count;
    }
    /* ==== uart_rx_8n1_program END ==== */
}


namespace RST {
    // If initial RST logic handled in .pio, RST default LOW, wait IRQ, then flip HIGH/LOW
    // Otherwise (which is better), RST default HIGH, wait IRQ, then flip HIGH/LOW
    static void rst_init(PIO pio, uint sm, uint offset, uint pin, float baud) {
        pio_sm_config c = rst_program_get_default_config(offset);
        // RST is default HIGH
        pio_sm_set_pins_with_mask64(pio, sm, 1ull << pin, 1ull << pin);
        // pindir is default OUT
        pio_sm_set_pindirs_with_mask64(pio, sm, 1ull << pin, 1ull << pin);
        // "pin" init -- GPIO control: PIO module takes control
        pio_gpio_init(pio, pin);
        // gpio_pull_up(pin);
        pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true); // start from out
        sm_config_set_set_pins(&c, pin, 1); // RST use "SET" and "IRQ" only
        sm_config_set_jmp_pin(&c, pin); // jmp RST: to flip the pin
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX); // because RST is output only
        float sys_hz = (float)clock_get_hz(clk_sys); // usually 125MHz
        sm_config_set_clkdiv(&c, sys_hz / (8 * baud)); // because we send 1 bit each 8 cycle
        // State_machine, load our configuration, and jump to the start of the program
        pio_sm_init(pio, sm, offset, &c);
        // State_machine, start
        // pio_sm_set_enabled(pio, sm, true);
    }
    static void on() {
        pio_sm_set_enabled(RST_pio, RST_sm, true);
    }
    static void off() {
        pio_sm_set_enabled(RST_pio, RST_sm, false);
    }
}


static void send_digests(PIO pio, uint sm, const Digest *digests, const size_t num_digests, const double baud, const double starttime, const double endtime) {
    const bool TARGET_DIR = true;    // only send when dir==true
    // bool       prevDir    = !TARGET_DIR; // force initial gap
    bool       prevDir    = TARGET_DIR;
    double     prevTime   = 40.93398898;
    const double transmitTimePerBit = ((double) 1) / baud;
    for (size_t i = 0; i < NUM_DIGESTS; ++i) {
        const Digest &d = digests[i];
        // Skip unwanted directions, but remember last seen
        if (d.dir != TARGET_DIR) {
            prevDir = d.dir;
            prevTime = d.timestamp;
            continue;
        }
        double timeDiffBetweenBytes = d.timestamp - prevTime;
        // update prevTime
        prevTime = d.timestamp;
        // end if after end
        if (d.timestamp > endtime) {
            break;
        }
        // next if before start
        if (d.timestamp < starttime) {
            continue;
        }
        // Wait the response to finsh if new frame
        // Assume new frame when direction changed or reasonable delay is observed between packets
        // (since bidirectional) add logic later, for now just wait some time
        if (d.dir != prevDir || timeDiffBetweenBytes > transmitTimePerBit * 32) {
            sleep_ms(5);
        }
        if ( timeDiffBetweenBytes > transmitTimePerBit * 3200) {
            sleep_ms(300);
        }
        // otherwise, send data
        pio_sm_put_blocking(pio, sm, d.byte_val);
        prevDir = d.dir;
    }
    sleep_ms(500); // after a section
}

namespace TESTRUN {
}

void task_tx() {
      // send_digests(TX_pio, TX_sm, digests, NUM_DIGESTS, UART_BAUD, 0.928, 500);
      send_digests(TX_pio, TX_sm, digests, NUM_DIGESTS, UART_BAUD, 16.65, 16.7); // baud and protocol negotiation
      // send_digests(TX_pio, TX_sm, digests, NUM_DIGESTS, UART_BAUD, 40.928, 40.98); 
      // send_digests(TX_pio, TX_sm, digests, NUM_DIGESTS, UART_BAUD, 58.97, 59.06);
}

static void run_multicore() {
    // core 1 TX
    multicore_launch_core1(task_tx);
    // core 0 RX
    while (true){
        RX::read_all(RX_pio, RX_sm);
    }
}

static void send_reset() {
    gpio_init(TX_PIN);
    gpio_init(RST_PIN);
    gpio_set_dir(TX_PIN, GPIO_OUT);
    gpio_set_dir(RST_PIN, GPIO_OUT);
    gpio_put(TX_PIN, 1);  // TX HIGH
    gpio_put(RST_PIN, 0); // RST LOW
    sleep_ms(20);       // assume a initial state, nothing before this

    // TX LOW 20ms, on 10ms RST HIGH
    gpio_put(TX_PIN, 0);
    sleep_ms(10);
    gpio_put(RST_PIN, 1);
    sleep_ms(10);
    // TX HIGH
    gpio_put(TX_PIN, 1);
}

static void init() {
    stdio_init_all();               // USB COM printf init
    send_reset();
    // Load program; return instruction memory offset the program is loaded at, or -1 for error
    int offset = pio_add_program(TX_pio, &uart_tx_8n2_program);
    if (offset < 0) { printf("ERROR_CANNOT_LOAD_PROGRAM"); }
    TX::uart_tx_8n2_program_init(TX_pio, TX_sm, (uint)offset, TX_PIN, UART_BAUD);

    int RX_offset = pio_add_program(RX_pio, &uart_rx_8n1_program);
    hard_assert(RX_offset); // RX_offset >= 0;
    RX::uart_rx_8n1_program_init(RX_pio, RX_sm, (uint)RX_offset, RX_PIN, UART_BAUD);

    int RST_offset = pio_add_program(RST_pio, &rst_program);
    hard_assert(RST_offset);
    RST::rst_init(RST_pio, RST_sm, (uint)RST_offset, RST_PIN, UART_BAUD);
}
static void run() {
    TX::on();
    RX::on();
    RST::on();
    run_multicore();
}

int main() {
    init();
    run();
    while (true) tight_loop_contents();
    return 0;
}

