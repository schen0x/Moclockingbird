// RP2350A (Rpi pico 2 W)
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "uart_tx_8n2.pio.h"   // the .h auto generated by pioasm from .pio file
#include "stdio.h"

/**
 * IN pio: the PIO instance, pio0 or pio1
 * IN sm: the State machine index (0..3)
 * IN offset: the instruction offset of the loaded program
 * IN pin: abs pin number?
 * IN baud: baud
 */
static void uart_tx_8n2_program_init(PIO pio, uint sm, uint offset, uint pin, float baud) {
    pio_sm_config c = uart_tx_8n2_program_get_default_config(offset);
    // "pin" init -- GPIO control: PIO module takes control
    pio_gpio_init(pio, pin);
    // set the direction of "pin" of pio in sm to output during the init
    // because we are the debugger and we write first
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true); // start from out
    sm_config_set_set_pins(&c, pin, 1);
    sm_config_set_out_pins(&c, pin, 1);
    // TX FIFO length=4 (4x32bits) is used for transmit, RX FIFO length=4 is used for receive.
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_NONE);
    sm_config_set_out_shift(&c, true, true, 8); // (c, LSB=true, autopull=true, 8 bits a time) // FIFO (4x32bits) -> OSR (32 bits)
    float sys_hz = (float)clock_get_hz(clk_sys); // usually 125MHz
    /**
     * The clock divider slows the state machineâ€™s execution by masking the system
     * clock on some cycles, in a repeating pattern, so that the state machine does
     * not advance. Effectively this produces a slower clock for the state machine
     * to run from, which can be used to generate e.g. a particular UART baud rate.
     * 
     * An integer clock divisor of n will cause the state machine to run 1 cycle in every n.
     * may jitter if div too small (when baud too high) and is float
    */
    sm_config_set_clkdiv(&c, sys_hz / baud);
    // State_machine, load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // State_machine, start
    pio_sm_set_enabled(pio, sm, true);
}


/*
 * Each STATE_MACHINE has 2 FIFOs, each FIFO is 4x32 bits
 * the .pio `OUT pin 1` shift 1 bit from the *OSR* to the pin
 * (FIFO is not OSR, so either config autopull `sm_config_set_out_shift`, or `PULL` in .pio manually)
 * (if manually: pio_sm_put_block(pio, sm, (uint32_t)bytes[i] << 24)), then `PULL` (32 bits), but `OUT` 8 bits only
*/
static void uart_tx_8n2_send_bytes(PIO pio, uint sm, const uint8_t *bytes, size_t length) {
    for (size_t i = 0; i < length; ++i) {
        // alternative raw method: // pio->txf[sm] = (125000000 / (2 * 250)) - 3;
        // the function stalls the processor when the TX FIFO is full
        // TX FIFO is 4 x 32 bits (uint32_t), but it's fine since the sm is configured to autopull 8 bits a time
        pio_sm_put_blocking(pio, sm, bytes[i]);
    }
}

int main() {
    const uint TX_PIN = 0;          // GP0
    const float UART_BAUD = 115200;
    stdio_init_all();               // for USB debug printf 
    PIO pio = pio0; // pio0 or pio1
    uint sm  = 0; // sm could be 0..3

    // Attempt to load the program, return the instruction memory offset the program is loaded at, or -1 for error
    int offset = pio_add_program(pio, &uart_tx_8n2_program);
    if (offset < 0) {
        printf("ERROR_CANNOT_LOAD_PROGRAM");
    }
    uart_tx_8n2_program_init(pio, sm, (uint)offset, TX_PIN, UART_BAUD);

    const uint8_t payload[] = { 0x1, 0x2, 0x3, 0x4, 0x55 };
    while (true) {
        uart_tx_8n2_send_bytes(pio, sm, payload, sizeof(payload));
    }

    return 0;
}

